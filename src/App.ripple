import { track } from 'ripple';

const STORAGE_KEY = 'wc-text';

function loadText(): string {
	try {
		return localStorage.getItem(STORAGE_KEY) ?? '';
	} catch {
		return '';
	}
}

function saveText(value: string) {
	try {
		localStorage.setItem(STORAGE_KEY, value);
	} catch {
		// storage full or unavailable
	}
}

export component App() {
	let text = track(loadText());
	let showWords = track(true);
	let isTyping = track(false);
	let isFocused = track(false);
	let hasSelection = track(false);
	let caretX = track(0);
	let caretY = track(0);

	let wordCount = track(() => {
		const trimmed = (@text).trim();
		if (trimmed === '') return 0;
		return trimmed.split(/\s+/).length;
	});

	let charCount = track(() => (@text).length);

	let caretVisible = track(() => @isFocused && !@hasSelection);

	let textareaRef: HTMLTextAreaElement | undefined;
	let mirrorRef: HTMLDivElement | undefined;
	let typingTimeout: ReturnType<typeof setTimeout> | undefined;
	let saveTimeout: ReturnType<typeof setTimeout> | undefined;

	function autoResize() {
		const textarea = textareaRef;
		if (!textarea) return;
		textarea.style.height = 'auto';
		textarea.style.height = textarea.scrollHeight + 'px';
	}

	function measureCaret() {
		const textarea = textareaRef;
		const mirror = mirrorRef;
		if (!textarea || !mirror) return;

		// Check for selection
		const start = textarea.selectionStart ?? 0;
		const end = textarea.selectionEnd ?? 0;
		@hasSelection = start !== end;

		if (start !== end) return;

		const textBefore = textarea.value.substring(0, start);

		// Mirror the textarea's styling exactly
		const style = window.getComputedStyle(textarea);
		mirror.style.font = style.font;
		mirror.style.letterSpacing = style.letterSpacing;
		mirror.style.wordSpacing = style.wordSpacing;
		mirror.style.lineHeight = style.lineHeight;
		mirror.style.paddingLeft = style.paddingLeft;
		mirror.style.paddingRight = style.paddingRight;
		mirror.style.paddingTop = style.paddingTop;
		mirror.style.width = style.width;
		mirror.style.whiteSpace = 'pre-wrap';
		mirror.style.wordWrap = 'break-word';
		mirror.style.overflowWrap = 'break-word';

		// Put text before cursor + a span marker
		mirror.innerHTML = '';
		const textNode = document.createTextNode(textBefore);
		const marker = document.createElement('span');
		marker.textContent = 'â€‹';
		mirror.appendChild(textNode);
		mirror.appendChild(marker);

		const markerRect = marker.getBoundingClientRect();
		const textareaRect = textarea.getBoundingClientRect();

		@caretX = markerRect.left - textareaRect.left;
		@caretY = markerRect.top - textareaRect.top;
	}

	function handleInput(e: Event) {
		const target = e.target as HTMLTextAreaElement;
		@text = target.value;

		// Persist to localStorage (debounced)
		if (saveTimeout) clearTimeout(saveTimeout);
		saveTimeout = setTimeout(() => saveText(@text), 300);

		@isTyping = true;
		if (typingTimeout) clearTimeout(typingTimeout);
		typingTimeout = setTimeout(() => {
			@isTyping = false;
		}, 600);

		autoResize();
		requestAnimationFrame(measureCaret);
	}

	function handleSelect(e?: Event) {
		// Stop animation and show solid caret when clicking/moving cursor
		@isTyping = true;
		if (typingTimeout) clearTimeout(typingTimeout);
		typingTimeout = setTimeout(() => {
			@isTyping = false;
		}, 600);
		requestAnimationFrame(measureCaret);
	}

	function focusTextarea(e?: MouseEvent) {
		const textarea = textareaRef;
		if (!textarea) return;
		
		// If clicking below the text content, move cursor to end
		if (e) {
			const rect = textarea.getBoundingClientRect();
			const clickY = e.clientY;
			const textBottom = rect.top + textarea.scrollHeight;
			
			if (clickY > textBottom) {
				// Clicked below the text, move cursor to end
				const endPos = textarea.value.length;
				textarea.setSelectionRange(endPos, endPos);
			}
		}
		
		textarea.focus();
		@isTyping = true;
		if (typingTimeout) clearTimeout(typingTimeout);
		typingTimeout = setTimeout(() => {
			@isTyping = false;
		}, 600);
		requestAnimationFrame(measureCaret);
	}

	<div
		class="min-h-screen flex flex-col items-center bg-zinc-950 py-4 px-6 cursor-text"
		onClick={focusTextarea}
	>
			<h1
				class="text-sm font-medium tracking-wider text-zinc-600 select-none pb-2"
			>
				{'Word Counter'}
			</h1>

			<a
				href="https://github.com/quick007/word-counter"
				target="_blank"
				rel="noopener noreferrer"
				class="absolute top-4 right-4 text-zinc-600 hover:text-zinc-400 transition-colors duration-200"
				aria-label="View source on GitHub"
				onClick={(e: MouseEvent) => e.stopPropagation()}
			>
				<svg
					xmlns="http://www.w3.org/2000/svg"
					width="20"
					height="20"
					viewBox="0 0 24 24"
					fill="currentColor"
				>
					<path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
				</svg>
			</a>

		<div class="relative w-full max-w-3xl flex-1">
			<textarea
				class="editor-area w-full bg-transparent border-none outline-none text-zinc-300 text-base leading-[1.85] resize-none overflow-hidden"
				{ref (el: HTMLTextAreaElement) => {
					textareaRef = el;
					el.value = @text;
					el.focus();
					requestAnimationFrame(() => {
						autoResize();
						measureCaret();
					});
				}}
				onInput={handleInput}
				onSelect={handleSelect}
				onClick={handleSelect}
				onKeyDown={handleSelect}
				onKeyUp={handleSelect}
				onFocus={() => {
					@isFocused = true;
					requestAnimationFrame(measureCaret);
				}}
				onBlur={() => {
					@isFocused = false;
				}}
				placeholder="Start typing..."
				spellcheck={true}
			/>

			<div
				class="mirror-div pointer-events-none absolute top-0 left-0"
				aria-hidden="true"
				{ref (el: HTMLDivElement) => {
					mirrorRef = el;
				}}
			/>

			if (@caretVisible) {
				<div
					class={{
						'caret pointer-events-none absolute top-0 left-0': true,
						'caret-typing': @isTyping,
						'caret-idle': !@isTyping,
					}}
					style={{
						transform: `translate(${@caretX}px, ${@caretY}px)`,
					}}
				/>
			}
		</div>

		<div class="flex justify-center mt-6 fixed bottom-4">
			<button
				class="cursor-pointer px-4 py-1.5 text-[0.95rem] font-medium select-none transition-all duration-300 rounded-full bg-linear-to-br from-white/[0.06] via-white/[0.02] to-white/[0.05] border border-white/[0.08] backdrop-blur-xl backdrop-saturate-[1.4] shadow-[0_0_0_0.5px_rgba(255,255,255,0.04),0_2px_8px_rgba(0,0,0,0.25)] inset-shadow-[0_1px_0_rgba(255,255,255,0.06)] hover:from-white/[0.09] hover:via-white/[0.04] hover:to-white/[0.07] hover:border-white/[0.12] hover:shadow-[0_0_0_0.5px_rgba(255,255,255,0.06),0_4px_12px_rgba(0,0,0,0.3)]"
				onClick={(e: MouseEvent) => {
					e.stopPropagation();
					@showWords = !@showWords;
				}}
			>
				if (@showWords) {
					<span class="text-blue-400/80 tabular-nums font-mono text-[0.95rem]">
						{@wordCount}
					</span>
					<span class="text-zinc-400">{@wordCount === 1 ? ' word' : ' words'}</span>
				} else {
					<span class="text-blue-400/80 tabular-nums font-mono text-[0.95rem]">
						{@charCount}
					</span>
					<span class="text-zinc-400">{@charCount === 1 ? ' character' : ' characters'}</span>
				}
			</button>
		</div>
	</div>
}
