import { track, effect } from 'ripple';
import { CmdKMenu } from './components/CmdKMenu/component.ripple';
import { loadStashes, addStash, removeStash, type StashItem } from './components/CmdKMenu/cmdk-utils.ts';
import { CommandLine } from './components/icons/CommandLine.ripple';
import { GitHub } from './components/icons/GitHub.ripple';

const STORAGE_KEY = 'wc-text';

function loadText(): string {
	return localStorage.getItem(STORAGE_KEY) ?? '';
}

function saveText(value: string) {
	localStorage.setItem(STORAGE_KEY, value);
}

export component App() {
	let text = track(loadText());
	let showWords = track(true);
	let isTyping = track(false);
	let isFocused = track(false);
	let hasSelection = track(false);
	let caretX = track(0);
	let caretY = track(0);
	let stashes = track(loadStashes());
	let cmdkOpen = track(false);

	let wordCount = track(() => {
		const trimmed = (@text).trim();
		if (trimmed === '') return 0;
		return trimmed.split(/\s+/).length;
	});

	let charCount = track(() => (@text).length);

	let caretVisible = track(() => @isFocused && !@hasSelection);

	let textareaRef: HTMLTextAreaElement | undefined;
	let mirrorRef: HTMLDivElement | undefined;
	let typingTimeout: ReturnType<typeof setTimeout> | undefined;
	let saveTimeout: ReturnType<typeof setTimeout> | undefined;

	function autoResize() {
		const textarea = textareaRef;
		if (!textarea) return;
		textarea.style.height = 'auto';
		textarea.style.height = textarea.scrollHeight + 'px';
	}

	function measureCaret() {
		const textarea = textareaRef;
		const mirror = mirrorRef;
		if (!textarea || !mirror) return;

		const start = textarea.selectionStart ?? 0;
		const end = textarea.selectionEnd ?? 0;
		@hasSelection = start !== end;

		if (start !== end) return;

		const textBefore = textarea.value.substring(0, start);

		const style = window.getComputedStyle(textarea);
		mirror.style.font = style.font;
		mirror.style.letterSpacing = style.letterSpacing;
		mirror.style.wordSpacing = style.wordSpacing;
		mirror.style.lineHeight = style.lineHeight;
		mirror.style.paddingLeft = style.paddingLeft;
		mirror.style.paddingRight = style.paddingRight;
		mirror.style.paddingTop = style.paddingTop;
		mirror.style.width = style.width;
		mirror.style.whiteSpace = 'pre-wrap';
		mirror.style.wordWrap = 'break-word';
		mirror.style.overflowWrap = 'break-word';

		mirror.innerHTML = '';
		const textNode = document.createTextNode(textBefore);
		const marker = document.createElement('span');
		marker.textContent = 'â€‹';
		mirror.appendChild(textNode);
		mirror.appendChild(marker);

		const markerRect = marker.getBoundingClientRect();
		const textareaRect = textarea.getBoundingClientRect();

		@caretX = markerRect.left - textareaRect.left;
		@caretY = markerRect.top - textareaRect.top;
	}

	function handleInput(e: Event) {
		const target = e.target as HTMLTextAreaElement;
		@text = target.value;

		if (saveTimeout) clearTimeout(saveTimeout);
		saveTimeout = setTimeout(() => saveText(@text), 300);

		@isTyping = true;
		if (typingTimeout) clearTimeout(typingTimeout);
		typingTimeout = setTimeout(() => {
			@isTyping = false;
		}, 600);

		autoResize();
		requestAnimationFrame(measureCaret);
	}

	function handleSelect(e?: Event) {
		@isTyping = true;
		if (typingTimeout) clearTimeout(typingTimeout);
		typingTimeout = setTimeout(() => {
			@isTyping = false;
		}, 600);
		requestAnimationFrame(measureCaret);
	}

	function focusTextarea(e?: MouseEvent) {
		if (@cmdkOpen) return;
		const textarea = textareaRef;
		if (!textarea) return;

		if (e) {
			const rect = textarea.getBoundingClientRect();
			const clickY = e.clientY;
			const textBottom = rect.top + textarea.scrollHeight;

			if (clickY > textBottom) {
				const endPos = textarea.value.length;
				textarea.setSelectionRange(endPos, endPos);
			}
		}

		textarea.focus();
		@isTyping = true;
		if (typingTimeout) clearTimeout(typingTimeout);
		typingTimeout = setTimeout(() => {
			@isTyping = false;
		}, 600);
		requestAnimationFrame(measureCaret);
	}

	function scrollCaretIntoView() {
		if (!@isFocused || @hasSelection) return;

		requestAnimationFrame(() => {
			const caret = document.querySelector('.caret');
			if (!caret) return;

			const scrollBottom = window.scrollY + window.innerHeight;
			const docHeight = document.documentElement.scrollHeight;

			if (@isTyping && docHeight - scrollBottom < 150) {
				window.scrollTo({ top: docHeight, behavior: 'smooth' });
			} else {
				caret.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
			}
		});
	}

	function handleStash() {
		if (!@text.trim()) return;
		@stashes = addStash(@stashes, @text);
		@text = '';
		if (textareaRef) {
			textareaRef.value = '';
			autoResize();
		}
		saveText('');
	}

	function handleStashPop() {
		if (@stashes.length === 0) return;
		const [first, ...rest] = @stashes;
		@stashes = rest;
		@text = first.text;
		if (textareaRef) {
			textareaRef.value = first.text;
			autoResize();
		}
		saveText(first.text);
	}

	function handleStashRestore(stash: StashItem) {
		@stashes = removeStash(@stashes, stash.id);
		@text = stash.text;
		if (textareaRef) {
			textareaRef.value = stash.text;
			autoResize();
		}
		saveText(stash.text);
	}

	async function handleCopy() {
		if (!@text.trim()) return;
		// @ts-expect-error
		await navigator.clipboard.writeText(@text);
	}

	effect(() => {
		const handler = (e: KeyboardEvent) => {
			if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === 'c') {
				e.preventDefault();
				handleCopy();
			} else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') {
				e.preventDefault();
				@cmdkOpen = !@cmdkOpen;
			}
		};
		document.addEventListener('keydown', handler);
		return () => document.removeEventListener('keydown', handler);
	});

	effect(() => {
		// Watch caret position and focus state to trigger scroll
		if (@isFocused && !@hasSelection) {
			const y = @caretY;
			scrollCaretIntoView();
		}
	});

	<div
		class="min-h-screen flex flex-col items-center bg-zinc-950 px-3 cursor-text"
		onClick={focusTextarea}
	>
		<div
			class="bg-zinc-950 xl:bg-transparent flex justify-between items-center w-full py-3 sticky top-0 z-30"
		>
			<h1 class="text-sm font-medium tracking-wider text-zinc-600 select-none ">
				{'Word Counter'}
			</h1>
			<div class="flex items-center gap-4">
				<button
					onClick={(e: MouseEvent) => {
						e.stopPropagation();
						@cmdkOpen = true;
					}}
					class="text-zinc-600 hover:text-zinc-400 transition-colors duration-200 bg-red-500y"
					aria-label="Open command menu"
					title="Command menu (Ctrl+K)"
				>
					<CommandLine  />
				</button>

				<a
					href="https://github.com/quick007/word-counter"
					target="_blank"
					rel="noopener noreferrer"
					class="text-zinc-600 hover:text-zinc-400 transition-colors duration-200"
					aria-label="View source on GitHub"
					onClick={(e: MouseEvent) => e.stopPropagation()}
				>
					<GitHub class="size-5" />
				</a>
			</div>
		</div>

		<div class="relative w-full max-w-3xl flex-1">
			<textarea
				class="editor-area w-full bg-transparent border-none outline-none text-zinc-300 text-base leading-[1.85] resize-none overflow-hidden"
				{ref (el: HTMLTextAreaElement) => {
					textareaRef = el;
					el.value = @text;
					el.focus();
					requestAnimationFrame(() => {
						autoResize();
						measureCaret();
					});
				}}
				onInput={handleInput}
				onSelect={handleSelect}
				onClick={handleSelect}
				onKeyDown={handleSelect}
				onKeyUp={handleSelect}
				onFocus={() => {
					@isFocused = true;
					requestAnimationFrame(measureCaret);
				}}
				onBlur={() => {
					@isFocused = false;
				}}
				placeholder="Start typing..."
				spellcheck={true}
			/>

			<div
				class="mirror-div pointer-events-none absolute top-0 left-0"
				aria-hidden="true"
				{ref (el: HTMLDivElement) => {
					mirrorRef = el;
				}}
			/>

			if (@caretVisible) {
				<div
					class={{
						'caret pointer-events-none absolute top-0 left-0': true,
						'caret-typing': @isTyping,
						'caret-idle': !@isTyping,
					}}
					style={{
						transform: `translate(${@caretX}px, ${@caretY}px)`,
					}}
				/>
			}
		</div>

		<div class="h-16" />

		<div class="flex justify-center fixed bottom-4">
			<button
				class="cursor-pointer px-4 py-1.5 text-[0.95rem] font-medium select-none transition-all duration-300 rounded-full bg-linear-to-br from-white/[0.06] via-white/[0.02] to-white/[0.05] border border-white/[0.08] backdrop-blur-xs backdrop-saturate-[1.4] shadow-[0_0_0_0.5px_rgba(255,255,255,0.04),0_2px_8px_rgba(0,0,0,0.25)] inset-shadow-[0_1px_0_rgba(255,255,255,0.06)] hover:from-white/[0.09] hover:via-white/[0.04] hover:to-white/[0.07] hover:border-white/[0.12] hover:shadow-[0_0_0_0.5px_rgba(255,255,255,0.06),0_4px_12px_rgba(0,0,0,0.3)]"
				onClick={(e: MouseEvent) => {
					e.stopPropagation();
					@showWords = !@showWords;
				}}
			>
				if (@showWords) {
					<span class="text-blue-400/80 tabular-nums font-mono text-[0.95rem]">
						{@wordCount}
					</span>
					<span class="text-zinc-400">{@wordCount === 1 ? ' word' : ' words'}</span>
				} else {
					<span class="text-blue-400/80 tabular-nums font-mono text-[0.95rem]">
						{@charCount}
					</span>
					<span class="text-zinc-400">
						{@charCount === 1 ? ' character' : ' characters'}
					</span>
				}
			</button>
		</div>

		<CmdKMenu
			isOpen={@cmdkOpen}
			onClose={() => (@cmdkOpen = false)}
			{@stashes}
			onStash={handleStash}
			onStashPop={handleStashPop}
			onStashRestore={handleStashRestore}
			onToggleCount={() => (@showWords = !@showWords)}
			onCopy={handleCopy}
			{@showWords}
			hasText={@text.trim().length > 0}
		/>
	</div>
}
