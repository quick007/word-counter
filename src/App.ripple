import { track, effect } from 'ripple';
import { CmdKMenu } from './components/CmdKMenu/component.ripple';
import {
	loadStashes,
	addStash,
	removeStash,
	type StashItem,
} from './components/CmdKMenu/cmdk-utils.ts';
import { CommandLine } from './components/icons/CommandLine.ripple';
import { GitHub } from './components/icons/GitHub.ripple';

const STORAGE_KEY = 'wc-text';
const PROMPT_KEY = 'wc-prompt';
const PROMPT_VISIBLE_KEY = 'wc-prompt-visible';

function loadText(): string {
	return localStorage.getItem(STORAGE_KEY) ?? '';
}

function saveText(value: string) {
	localStorage.setItem(STORAGE_KEY, value);
}

function loadPrompt(): string {
	return localStorage.getItem(PROMPT_KEY) ?? '';
}

function savePrompt(value: string) {
	localStorage.setItem(PROMPT_KEY, value);
}

function loadPromptVisible(): boolean {
	return localStorage.getItem(PROMPT_VISIBLE_KEY) === 'true';
}

function savePromptVisible(value: boolean) {
	localStorage.setItem(PROMPT_VISIBLE_KEY, value ? 'true' : 'false');
}

export component App() {
	let text = track(loadText());
	let showWords = track(true);
	let isTyping = track(false);
	let isFocused = track(false);
	let isPromptFocused = track(false);
	let mainHasSelection = track(false);
	let promptHasSelection = track(false);
	let isPromptTyping = track(false);
	let caretX = track(0);
	let caretY = track(0);
	let textareaOffsetTop = track(0);
	let promptCaretX = track(0);
	let promptCaretY = track(0);
	let promptMirrorRef: HTMLDivElement | undefined;
	let stashes = track(loadStashes());
	let cmdkOpen = track(false);
	let showPrompt = track(loadPromptVisible());
	let promptText = track(loadPrompt());
	let hasMounted = track(false);
	let promptTextareaRef: HTMLTextAreaElement | undefined;
	let hasFontMetricsSync = false;

	let wordCount = track(() => {
		const trimmed = (@text).trim();
		if (trimmed === '') return 0;
		return trimmed.split(/\s+/).length;
	});

	let charCount = track(() => (@text).length);

	let caretVisible = track(() => @isFocused && !@mainHasSelection && !@isPromptFocused);
	let promptCaretVisible = track(() => @isPromptFocused && !@promptHasSelection);

	let textareaRef: HTMLTextAreaElement | undefined;
	let mirrorRef: HTMLDivElement | undefined;
	let typingTimeout: ReturnType<typeof setTimeout> | undefined;
	let promptTypingTimeout: ReturnType<typeof setTimeout> | undefined;
	let saveTimeout: ReturnType<typeof setTimeout> | undefined;
	let mainCaretFrame: number | undefined;
	let promptCaretFrame: number | undefined;

	function autoResize() {
		const textarea = textareaRef;
		if (!textarea) return;
		textarea.style.height = 'auto';
		textarea.style.height = textarea.scrollHeight + 'px';
		syncTextareaOffset();
	}

	function syncTextareaOffset() {
		const textarea = textareaRef;
		if (!textarea) return;
		@textareaOffsetTop = textarea.offsetTop;
	}

	function syncLayoutWithFonts() {
		if (hasFontMetricsSync) return;
		hasFontMetricsSync = true;
		const fonts = document.fonts;
		if (!fonts) {
			autoResize();
			scheduleMainCaretSync();
			schedulePromptCaretSync();
			return;
		}
		fonts.ready.then(() => {
			autoResize();
			if (promptTextareaRef) {
				promptTextareaRef.style.height = 'auto';
				promptTextareaRef.style.height = promptTextareaRef.scrollHeight + 'px';
			}
			scheduleMainCaretSync();
			schedulePromptCaretSync();
		});
	}

	function computeCaretPosition(textarea: HTMLTextAreaElement, mirror: HTMLDivElement) {
		const start = textarea.selectionStart ?? 0;
		const end = textarea.selectionEnd ?? 0;
		const hasSelection = start !== end;
		if (hasSelection) {
			return { hasSelection, x: 0, y: 0 };
		}

		const textBefore = textarea.value.substring(0, start);
		const style = window.getComputedStyle(textarea);
		mirror.style.font = style.font;
		mirror.style.letterSpacing = style.letterSpacing;
		mirror.style.wordSpacing = style.wordSpacing;
		mirror.style.lineHeight = style.lineHeight;
		mirror.style.padding = style.padding;
		mirror.style.border = style.border;
		mirror.style.boxSizing = style.boxSizing;
		mirror.style.width = style.width;
		mirror.style.textTransform = style.textTransform;
		mirror.style.textIndent = style.textIndent;
		mirror.style.tabSize = style.tabSize;
		mirror.style.whiteSpace = 'pre-wrap';
		mirror.style.wordBreak = 'break-word';
		mirror.style.overflowWrap = 'break-word';

		mirror.innerHTML = '';
		const textNode = document.createTextNode(textBefore);
		const marker = document.createElement('span');
		marker.textContent = 'â€‹';
		marker.style.display = 'inline-block';
		mirror.appendChild(textNode);
		mirror.appendChild(marker);

		const markerRect = marker.getBoundingClientRect();
		const textareaRect = textarea.getBoundingClientRect();
		const lineHeight = parseFloat(style.lineHeight);
		const fontSize = parseFloat(style.fontSize);
		const offsetY =
			Number.isFinite(lineHeight) && Number.isFinite(fontSize)
				? Math.max(0, (lineHeight - fontSize) * 0.3)
				: 0;

		return {
			hasSelection,
			x: markerRect.left - textareaRect.left,
			y: markerRect.top - textareaRect.top + offsetY,
		};
	}

	function syncMainCaret() {
		const textarea = textareaRef;
		const mirror = mirrorRef;
		if (!textarea || !mirror) return;
		const result = computeCaretPosition(textarea, mirror);
		@mainHasSelection = result.hasSelection;
		if (!result.hasSelection) {
			@caretX = result.x;
			@caretY = result.y;
		}
	}

	function syncPromptCaret() {
		const textarea = promptTextareaRef;
		const mirror = promptMirrorRef;
		if (!textarea || !mirror) return;
		const result = computeCaretPosition(textarea, mirror);
		@promptHasSelection = result.hasSelection;
		if (!result.hasSelection) {
			@promptCaretX = result.x;
			@promptCaretY = result.y;
		}
	}

	function scheduleMainCaretSync() {
		if (mainCaretFrame) cancelAnimationFrame(mainCaretFrame);
		mainCaretFrame = requestAnimationFrame(() => {
			syncTextareaOffset();
			syncMainCaret();
			mainCaretFrame = undefined;
		});
	}

	function schedulePromptCaretSync() {
		if (promptCaretFrame) cancelAnimationFrame(promptCaretFrame);
		promptCaretFrame = requestAnimationFrame(() => {
			syncPromptCaret();
			promptCaretFrame = undefined;
		});
	}

	function handleInput(e: Event) {
		const target = e.target as HTMLTextAreaElement;
		@text = target.value;

		if (saveTimeout) clearTimeout(saveTimeout);
		saveTimeout = setTimeout(() => saveText(@text), 300);

		@isTyping = true;
		if (typingTimeout) clearTimeout(typingTimeout);
		typingTimeout = setTimeout(() => {
			@isTyping = false;
		}, 600);

		autoResize();
		scheduleMainCaretSync();
	}

	function handleSelect(e?: Event) {
		@isTyping = true;
		if (typingTimeout) clearTimeout(typingTimeout);
		typingTimeout = setTimeout(() => {
			@isTyping = false;
		}, 600);
		scheduleMainCaretSync();
	}

	function focusTextarea(e?: MouseEvent) {
		if (@cmdkOpen) return;
		const textarea = textareaRef;
		if (!textarea) return;

		if (e) {
			const rect = textarea.getBoundingClientRect();
			const clickY = e.clientY;
			const textBottom = rect.top + textarea.scrollHeight;

			if (clickY > textBottom) {
				const endPos = textarea.value.length;
				textarea.setSelectionRange(endPos, endPos);
			}
		}

		textarea.focus();
		@isTyping = true;
		if (typingTimeout) clearTimeout(typingTimeout);
		typingTimeout = setTimeout(() => {
			@isTyping = false;
		}, 600);
		scheduleMainCaretSync();
	}

	function scrollCaretIntoView() {
		if (!@isFocused || @mainHasSelection) return;

		requestAnimationFrame(() => {
			const caret = document.querySelector('.caret');
			if (!caret) return;

			const scrollBottom = window.scrollY + window.innerHeight;
			const docHeight = document.documentElement.scrollHeight;

			if (@isTyping && docHeight - scrollBottom < 150) {
				window.scrollTo({ top: docHeight, behavior: 'smooth' });
			} else {
				caret.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
			}
		});
	}

	function handleStash() {
		if (!@text.trim()) return;
		@stashes = addStash(@stashes, @text);
		@text = '';
		if (textareaRef) {
			textareaRef.value = '';
			autoResize();
		}
		saveText('');
	}

	function handleAddPrompt() {
		@showPrompt = true;
		savePromptVisible(true);
	}

	function handleRemovePrompt() {
		@showPrompt = false;
		savePromptVisible(false);
	}

	function handleStashPop() {
		if (@stashes.length === 0) return;
		const [first, ...rest] = @stashes;
		@stashes = rest;
		@text = first.text;
		if (textareaRef) {
			textareaRef.value = first.text;
			autoResize();
		}
		saveText(first.text);
	}

	function handleStashRestore(stash: StashItem) {
		@stashes = removeStash(@stashes, stash.id);
		@text = stash.text;
		if (textareaRef) {
			textareaRef.value = stash.text;
			autoResize();
		}
		saveText(stash.text);
	}

	function handleStashDelete(id: string) {
		@stashes = removeStash(@stashes, id);
	}

	async function handleCopy() {
		if (!@text.trim()) return;
		// @ts-expect-error
		await navigator.clipboard.writeText(@text);
	}

	function handleClear() {
		@text = '';
		@promptText = '';
		@showPrompt = false;
		if (textareaRef) {
			textareaRef.value = '';
			autoResize();
		}
		saveText('');
		savePrompt('');
		savePromptVisible(false);
	}

	effect(() => {
		const handler = (e: KeyboardEvent) => {
			if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === 'c') {
				e.preventDefault();
				handleCopy();
			} else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') {
				e.preventDefault();
				@cmdkOpen = !@cmdkOpen;
			}
		};
		document.addEventListener('keydown', handler);
		return () => document.removeEventListener('keydown', handler);
	});

	effect(() => {
		// Watch caret position and focus state to trigger scroll
		if (@isFocused && !@mainHasSelection) {
			const y = @caretY;
			scrollCaretIntoView();
		}
	});

	effect(() => {
		const handleResize = () => scheduleMainCaretSync();
		window.addEventListener('resize', handleResize);
		return () => window.removeEventListener('resize', handleResize);
	});

	effect(() => {
		const isVisible = @showPrompt;
		requestAnimationFrame(() => {
			syncTextareaOffset();
			scheduleMainCaretSync();
			schedulePromptCaretSync();
		});
	});

	<div
		class="min-h-screen flex flex-col items-center bg-zinc-950 px-3 cursor-text"
		onClick={focusTextarea}
	>
		<div
			class="bg-zinc-950 xl:bg-transparent flex justify-between items-center w-full py-3 sticky top-0 z-30"
		>
			<h1 class="text-sm font-medium tracking-wider text-zinc-600 select-none ">
				{'Word Counter'}
			</h1>
			<div class="flex items-center gap-4">
				<button
					onClick={(e: MouseEvent) => {
						e.stopPropagation();
						@cmdkOpen = true;
					}}
					class="text-zinc-600 hover:text-zinc-400 transition-colors duration-200 bg-red-500y"
					aria-label="Open command menu"
					title="Command menu (Ctrl+K)"
				>
					<CommandLine />
				</button>

				<a
					href="https://github.com/quick007/word-counter"
					target="_blank"
					rel="noopener noreferrer"
					class="text-zinc-600 hover:text-zinc-400 transition-colors duration-200"
					aria-label="View source on GitHub"
					onClick={(e: MouseEvent) => e.stopPropagation()}
				>
					<GitHub class="size-5" />
				</a>
			</div>
		</div>

		<div class="relative w-full max-w-3xl flex-1">
			if (@showPrompt) {
				<textarea
					class="prompt-textarea w-full bg-transparent border-none placeholder:italic outline-none text-zinc-400 text-base placeholder:text-zinc-500 leading-[1.85] resize-none overflow-hidden mb-4"
					style={{
						caretColor: 'transparent',
					}}
					value={@promptText}
					onInput={(e: Event) => {
						@promptText = (e.target as HTMLTextAreaElement).value;
						savePrompt(@promptText);
						const target = e.target as HTMLTextAreaElement;
						target.style.height = 'auto';
						target.style.height = target.scrollHeight + 'px';
						syncTextareaOffset();
						@isPromptTyping = true;
						if (promptTypingTimeout) clearTimeout(promptTypingTimeout);
						promptTypingTimeout = setTimeout(() => {
							@isPromptTyping = false;
						}, 600);
						schedulePromptCaretSync();
						scheduleMainCaretSync();
					}}
					onSelect={() => {
						@isPromptTyping = true;
						if (promptTypingTimeout) clearTimeout(promptTypingTimeout);
						promptTypingTimeout = setTimeout(() => {
							@isPromptTyping = false;
						}, 600);
						schedulePromptCaretSync();
					}}
					onKeyDown={() => {
						@isPromptTyping = true;
						if (promptTypingTimeout) clearTimeout(promptTypingTimeout);
						promptTypingTimeout = setTimeout(() => {
							@isPromptTyping = false;
						}, 600);
						schedulePromptCaretSync();
					}}
					onKeyUp={() => {
						@isPromptTyping = true;
						if (promptTypingTimeout) clearTimeout(promptTypingTimeout);
						promptTypingTimeout = setTimeout(() => {
							@isPromptTyping = false;
						}, 600);
						schedulePromptCaretSync();
					}}
					onClick={(e: MouseEvent) => {
						e.stopPropagation();
						@isPromptTyping = true;
						if (promptTypingTimeout) clearTimeout(promptTypingTimeout);
						promptTypingTimeout = setTimeout(() => {
							@isPromptTyping = false;
						}, 600);
						schedulePromptCaretSync();
					}}
					onFocus={() => {
						@isPromptFocused = true;
						schedulePromptCaretSync();
					}}
					onBlur={() => {
						@isPromptFocused = false;
					}}
					placeholder="Enter your prompt..."
					spellcheck={true}
					{ref (el: HTMLTextAreaElement) => {
					if (el) {
						promptTextareaRef = el;
						el.style.height = 'auto';
						el.style.height = el.scrollHeight + 'px';
						schedulePromptCaretSync();
						syncLayoutWithFonts();
					}
				}}
			/>
				<div
					class="prompt-mirror pointer-events-none absolute top-0 left-0"
					style={{
						opacity: '0',
						position: 'absolute',
						pointerEvents: 'none',
					}}
					aria-hidden="true"
					{ref (el: HTMLDivElement) => {
						promptMirrorRef = el;
					}}
				/>
				if (@promptCaretVisible) {
					<div
						class={{
							'caret pointer-events-none absolute top-0 left-0': true,
							'caret-typing': @isPromptTyping,
							'caret-idle': !@isPromptTyping,
						}}
						style={{
							transform: `translate(${@promptCaretX}px, ${@promptCaretY}px)`,
						}}
					/>
				}
			}
			<textarea
				class="editor-area w-full bg-transparent placeholder:italic placeholder:text-zinc-500 border-none outline-none text-zinc-300 text-base leading-[1.85] resize-none overflow-hidden"
				{ref (el: HTMLTextAreaElement) => {
				textareaRef = el;
				@textareaOffsetTop = el.offsetTop;
				el.value = @text;
					if (!@hasMounted) {
						@hasMounted = true;
						if (!@showPrompt) {
							el.focus();
						}
					}
				requestAnimationFrame(() => {
					autoResize();
					scheduleMainCaretSync();
				});
				syncLayoutWithFonts();
			}}
				onInput={handleInput}
				onSelect={handleSelect}
				onClick={handleSelect}
				onKeyDown={handleSelect}
				onKeyUp={handleSelect}
				onFocus={() => {
					@isFocused = true;
					scheduleMainCaretSync();
				}}
				onBlur={() => {
					@isFocused = false;
				}}
				placeholder="Start typing..."
				spellcheck={true}
			/>

			<div
				class="mirror-div pointer-events-none absolute left-0"
				style={{
					top: `${@textareaOffsetTop}px`,
				}}
				{ref (el: HTMLDivElement) => {
					mirrorRef = el;
				}}
				aria-hidden="true"
			/>

			if (@caretVisible) {
				<div
					class={{
						'caret pointer-events-none absolute left-0': true,
						'caret-typing': @isTyping,
						'caret-idle': !@isTyping,
					}}
					style={{
						top: `${@textareaOffsetTop}px`,
						transform: `translate(${@caretX}px, ${@caretY}px)`,
					}}
				/>
			}
		</div>

		<div class="h-16" />

		<div class="flex justify-center fixed bottom-4">
			<button
				class="cursor-pointer px-4 py-1.5 text-[0.95rem] font-medium select-none transition-all duration-300 rounded-full bg-linear-to-br from-white/[0.06] via-white/[0.02] to-white/[0.05] border border-white/[0.08] backdrop-blur-xs backdrop-saturate-[1.4] shadow-[0_0_0_0.5px_rgba(255,255,255,0.04),0_2px_8px_rgba(0,0,0,0.25)] inset-shadow-[0_1px_0_rgba(255,255,255,0.06)] hover:from-white/[0.09] hover:via-white/[0.04] hover:to-white/[0.07] hover:border-white/[0.12] hover:shadow-[0_0_0_0.5px_rgba(255,255,255,0.06),0_4px_12px_rgba(0,0,0,0.3)]"
				onClick={(e: MouseEvent) => {
					e.stopPropagation();
					@showWords = !@showWords;
				}}
			>
				if (@showWords) {
					<span class="text-blue-400/80 tabular-nums font-mono text-[0.95rem]">
						{@wordCount}
					</span>
					<span class="text-zinc-400">{@wordCount === 1 ? ' word' : ' words'}</span>
				} else {
					<span class="text-blue-400/80 tabular-nums font-mono text-[0.95rem]">
						{@charCount}
					</span>
					<span class="text-zinc-400">
						{@charCount === 1 ? ' character' : ' characters'}
					</span>
				}
			</button>
		</div>

		<CmdKMenu
			isOpen={@cmdkOpen}
			onClose={() => {
				@cmdkOpen = false;
				queueMicrotask(() => textareaRef?.focus());
			}}
			{@stashes}
			onStash={handleStash}
			onStashPop={handleStashPop}
			onStashRestore={handleStashRestore}
			onStashDelete={handleStashDelete}
			onToggleCount={() => (@showWords = !@showWords)}
			onCopy={handleCopy}
			onAddPrompt={handleAddPrompt}
			onRemovePrompt={handleRemovePrompt}
			onClear={handleClear}
			{@showWords}
			{@showPrompt}
			hasText={@text.trim().length > 0}
		/>
	</div>
}
